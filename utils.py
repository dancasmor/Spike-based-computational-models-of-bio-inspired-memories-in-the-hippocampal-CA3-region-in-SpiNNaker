
import time
import matplotlib.pyplot as plt
from operator import itemgetter
import os
import numpy as np


#####################################
# Input/Output
#####################################

def write_file(basePath, title, data):
    """
    Generic function to write the data into a file

    :param basePath: directory path where the file will be stored
    :param title: name of the file
    :param data: data to store in the file
    :return: full path to the file created, name of the file created
    """
    strDate = time.strftime("%Y_%m_%d__%H_%M_%S")
    filename = title + "_" + strDate
    fullPath = basePath + filename + ".txt"
    file = open(fullPath, "w")
    file.write(str(data))
    file.close()
    return fullPath, filename


def read_file(fullPath):
    """
    Read the file in fullPath

    :param fullPath: path + filename to the file to read
    :return: data read from the file or False if the file could not be accessed
    """
    try:
        file = open(fullPath, "r")
        return eval(file.read())
    except FileNotFoundError:
        return False


def check_folder(path):
    """
    Check if a folder exist and, if it does not exist, it creates it

    :param path: path where the folder is located or want to be created
    :return: the path if folder exist or has been created or False if the folder doesn't exist and can't be created
    """
    if not os.path.isdir(path):
        try:
            os.mkdir(path)
            return path
        except OSError as e:
            print("Error to create directory")
            return False
    else:
        return path


#####################################
# Data format
#####################################

def format_neo_data(tipo, stream, timeStream={}):
    """
    Format the streams of neo data to delete headers and/or make the data structure used in the rest of functions

    :param tipo: type of neo data ("v", "spikes" and "weights" supported)
    :param stream: data streams to be formated
    :param timeStream: (optional) {"simTime", "timeStep"} necessary to add the time stamp to the weights stream format
    :return: formated stream or Raise an error if is an unsopported type of data
    """
    if timeStream is None:
        timeStream = []
    if tipo == "v":
        formatStream = format_v_stream(stream)
    elif tipo == "spikes":
        formatStream = format_spike_stream(stream)
    elif tipo == "weights":
        formatStream = format_weight_stream(stream, timeStream)
    else:
        formatStream = False
    return formatStream


def format_v_stream(vStream):
    """
    Change the format of the neo data streams of membrane potentials and correct nan values

    :param vStream: neo streams of membrane potentials
    :return: v stream formated
    """
    formatV = []
    # Obtain the matrix of values ->
    #   each element represents a time_stamp and the content of that element the value for each neuron
    rawStream = vStream.as_array().tolist()
    # Extract the nnumber of neuron on each time stamp
    numNeurons = len(rawStream[0])
    # Reformat it so each element is a neuron and the content is the values for each time stamp
    for neuron in range(0, numNeurons):
        formatV.append([item[neuron] for item in rawStream])
    # Change nan values for -60 if it is the first value in the stream, the value of the previous instant if it is the
    #  last instant and the average of the instants before and after in another case
    for indexNeuron, neuron in enumerate(formatV):
        for indexTime, timeStamp in enumerate(neuron):
            if str(formatV[indexNeuron][indexTime]) == "nan":
                if indexTime == 0:
                    formatV[indexNeuron][indexTime] = -60.0
                elif indexTime >= len(neuron)-1:
                    formatV[indexNeuron][indexTime] = formatV[indexNeuron][indexTime-1]
                else:
                    formatV[indexNeuron][indexTime] = (formatV[indexNeuron][indexTime-1] +
                                                      formatV[indexNeuron][indexTime+1])/2
    return formatV


def format_spike_stream(spikes):
    """
    Change the format of the neo data streams of spikes generated by neurons

    :param spikesStream: neo stream of spikes
    :return: spikes stream formated
    """
    formatSpikes = []
    for neuron in spikes:
        formatSpikes.append(neuron.as_array().tolist())
    return formatSpikes


def format_weight_stream(weights, timeParam):
    """
    Change the format of the streams of weights recorded

    :param weightsStream: weight stream
    :param timeStreamParam: temporal parameters of the simulation -> {"simTime", "timeStep"}
    :return: formated weight stream -> {"srcNeuronId", "dstNeuronId", "w", "timeStamp"}
    """
    srcNeuronId, dstNeuronId, w, timeStampStream = [], [], [], []

    # Generate time stream in ms
    timeStream = generate_time_streams(timeParam["simTime"], timeParam["timeStep"], False, True)

    # For each time stamp:
    for indexStep, step in enumerate(weights):
        # For each synapse:
        for indexSyn, synapse in enumerate(step):
            srcNeuronId.append(synapse[0])
            dstNeuronId.append(synapse[1])
            w.append(synapse[2])
            timeStampStream.append(timeStream[indexStep])
    return {"srcNeuronId": srcNeuronId, "dstNeuronId": dstNeuronId, "w": w, "timeStamp": timeStampStream}


def get_last_stamp_synapse_list(dataPath, delay=1.0, synapse="PCL-PCL"):
    """
    Given full path filename of data file from a simulation, extract the last iteration weight

    :param dataPath: full path filename of data file from a simulation
    :param delay: delay to add to the synapses
    :param synapse: name of synapses that want to extract the weight
    :return: synapse list (src,dst,w) of last timestamp and other metadata
    """

    # Open file with weights
    data = read_file(dataPath)

    # Search weight variable with given synapse name
    w = {}
    for variable in data["variables"]:
        if variable["type"] == "w" and variable["popNameShort"] == synapse:
            w = variable["data"]

    # Check if data has been found
    if w == {}:
        print("Error to read the weight file. Try to redo training with recordWeight = True.")
        return False

    # Take the last timeStamp
    maxTimeStamp = max(list(set(w["timeStamp"])))

    # Take all indeces from the last timestamp
    maxTimeStampIndeces = [i for i, value in enumerate(w["timeStamp"]) if value == maxTimeStamp]

    # Get weight, source id and destiny id from that timestamp
    lastTimeStampWeights = itemgetter(*maxTimeStampIndeces)(w["w"])
    lastTimeStampSrcNeuron = itemgetter(*maxTimeStampIndeces)(w["srcNeuronId"])
    lastTimeStampDstNeuron = itemgetter(*maxTimeStampIndeces)(w["dstNeuronId"])

    # Create the list of data
    synapses = []
    for index, w_individual in enumerate(lastTimeStampWeights):
        synapses.append((lastTimeStampSrcNeuron[index], lastTimeStampDstNeuron[index], w_individual, delay))

    # Return list of synapse and metainformation of original STDP synapses
    return synapses, data["synParameters"][synapse]


#####################################
# Generation of data
#####################################

def generate_time_streams(simTime, timeStep, timeInSeg, endPlus=False):
    """
    Generates a time sequence in s or ms of the simulation duration using the timestep of the simulation

    :param simTime: duration of the simulation in ms
    :param timeStep: time step used in simulation in ms
    :param timeInSeg: time unit of the sequence: ms or s
    :param endPlus: (optional) bool to indicate if include the simTime stamp at the end of the sequence
    :return: temporal sequence
    """
    # Add the last time stamp of the time sequence or not
    if endPlus:
        endCount = 1
    else:
        endCount = 0

    # Generated time sequence in s o ms
    if timeInSeg:
        timeStream = generate_sequence(0, simTime + endCount, timeStep, 1000)
    else:
        timeStream = generate_sequence(0, simTime + endCount, timeStep, 1)
    return timeStream


def generate_sequence(start, stop, step, divisor):
    """
    Generate a sequence of numbers with the input conditions (start included, stop not included)

    :param start: start of sequence (included)
    :param stop: stop value of the sequence (non included)
    :param step: increment in each iteration
    :param divisor: value by which to divide the counting when storing it
    :return: sequence of generated values
    """
    sequence = []
    count = start
    while count < stop:
        sequence.append(float(count)/divisor)
        count = count + step
    return sequence


#####################################
# Plot
#####################################


def plot_spike_pc_dg(spikesPC, spikesDG, timeStream, colors, marginLim, title, rotateLabels, plot, saveFig, saveName, savePath):
    """
    Create a spike plot of all activations of DG and PC (CA3) neurons

    :param spikesPCdir: PCdir spike stream 
    :param spikesDG: DG spike stream 
    :param timeStream: time stamp stream
    :param colors: list of color for each population of neuron to represent
    :param marginLim: additional margin to the spike amplitude to mark the begin and end of the representation view
    :param title: title of the plot
    :param rotateLabels: if rotate (90ยบ) or not the labels of spikes
    :param plot: bool, if plot the figure
    :param saveFig: bool, if save the figure in a png file
    :param saveName: base name of the output png file
    :param savePath: path where to store the png file
    :return: full path (path + fig name) where the figure has been stored, if isSave is True
    """

    plt.figure(figsize=(24, 8))

    # Add PC dir, cont and DG spikes
    label = "DG"
    for spikeDG in spikesDG:
        plt.vlines(spikeDG, ymin=0 - marginLim, ymax=0.5 , color=colors[0], label=label)
        label = "_nolegend_"
    label = "PC"
    for spikePC in spikesPC:
        plt.vlines(spikePC, ymin=0, ymax=0.5 + marginLim, color=colors[1], label=label)
        label = "_nolegend_"

    # Make labels for spikes in each instant
    for stamp in timeStream:
        label = ""
        # For current instant, check if a spike has occurred
        sublabel = "DG"
        for indexNeuron, spikeDG in enumerate(spikesDG):
            if stamp in spikeDG:
                label = label + sublabel + str(indexNeuron)
                sublabel = "-"
        label = label + " "
        sublabel = "PC"
        for indexNeuron, spikePC in enumerate(spikesPC):
            if stamp in spikePC:
                label = label + sublabel + str(indexNeuron)
                sublabel = "-"
        # Add the label to the current instant
        plt.annotate(label, xy=(stamp+0.1, 0.01), rotation=90, fontsize=15)

    # Add metadata
    plt.xlabel("Simulation time (ms)", fontsize=15)
    plt.ylabel("Spikes", fontsize=15)
    plt.title(title, fontsize=15)
    plt.ylim([-marginLim, 0.5 + marginLim])
    plt.xlim(-0.5, max(timeStream) + 1.5)
    listXticks = list(set([spike for sublist in spikesPC for spike in sublist] \
                 + [spike for sublist in spikesDG for spike in sublist]))
    plt.xticks(listXticks, fontsize=15)
    plt.legend(bbox_to_anchor=(1.0, 1.0), loc='upper left', fontsize=15)
    if rotateLabels:
        plt.xticks(rotation=90)

    # Save and/or plot the figure
    if saveFig:
        plt.savefig(savePath + saveName + ".png")
    if plot:
        plt.show()
    plt.close()
    
    return savePath + saveName + ".png"
